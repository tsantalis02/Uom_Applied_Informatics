/*
File:a27f4.c
Στις περιπτώσεις κωδικών που αποτελούνται από ένα μεγάλο αριθμό ψηφίων (πχ. λογαριασμών τραπεζών, κωδικών πληρωμής κλπ)
    για την ασφάλεια των συναλλαγών θα πρέπει να υπάρχει ένας εύκολος τρόπος εξασφάλισης ότι ο χρήστης δεν πληκτρολογεί λάθος τα ψηφία.
    Ο τρόπος είναι να προστίθενται στους κωδικούς ψηφία ελέγχου. Ένας απλός τρόπος για το παραπάνω είναι να προστίθενται 2 ψηφία ελέγχου
    στο τέλος του κωδικού δημιουργώντας έτσι το τελικό κωδικό. Για παράδειγμα:
	   Αρχικός κωδικός (Ν)			Ψηφία Ελέγχου			Τελικός Κωδικός (ΕΝ)
		     12558				           60				           1255860
	        55257				           03				           5525703
    Τα ψηφία ελέγχου ενός αρχικού κωδικού Ν (long) δίνονται από το τύπο:
    	Ψηφία ελέγχου = (98 - (N*100) % 97) % 97    (1)
    Ο έλεγχος εγκυρότητας ενός τελικού κωδικού ΕΝ υπολογίζεται εύκολα ελέγχοντας αν η πράξη ΕΝ % 97 έχει ως αποτέλεσμα 1,
    δηλαδή δεδομένου ενός τελικού κωδικού EN αυτός είναι έγκυρος αν το ακέραιο υπόλοιπο του με τον αριθμό 97 είναι ένα.
    Να υλοποιήσετε:
    (α) Μια συνάρτηση encode η οποία δέχεται ένα αρχικό κωδικό (long) και επιστρέφει τον αντίστοιχο τελικό κωδικό (long).
    Αναφέρεται και πάλι ότι ο τελικός κωδικός προκύπτει από την προσθήκη στο τέλος ενός αρχικού κωδικού των ψηφίων ελέγχου,
    τα οποία δίνονται από το τύπο (1).
    (β) μια συνάρτηση check η οποία δέχεται ένα τελικό κωδικό και επιστρέφει TRUE αν είναι έγκυρος και FALSE σε αντίθετη περίπτωση.
    Αναφέρεται και πάλι ότι ο έλεγχος γίνεται εξετάζοντας αν το ακέραιο υπόλοιπο του τελικού κωδικού με το 97 είναι ίσο με 1.
    (γ) ένα πρόγραμμα το οποίο δέχεται από τον χρήστη δύο όρια αρχικών κωδικών (long) και εμφανίζει για κάθε κωδικό ανάμεσα σε αυτά
    τα δύο όρια τον αρχικό κωδικό, τον τελικό κωδικό και αν είναι έγκυρος ή όχι, σύμφωνα με τα παραδείγματα που ακολουθούν. Η εμφάνιση των
    μηνυμάτων θα γίνεται μέσω του κυρίως προγράμματος (συνάρτηση main(), δηλαδή η εντολή εμφάνισης των μηνυμάτων (printf) θα είναι στην main()).
    Υποθέστε ότι ο χρήστης δίνει πάντα όρια μεγαλύτερα του 0 και ότι το κάτω όριο (lower limit) θα είναι πάντα μικρότερο ή ίσο με το το άνω όριο
    (upper limit)). Δεν απαιτείται έλεγχος.
    Σημείωση: Αν το πρόγραμμά σας είναι σωστό, τότε όλοι οι τελικοί κωδικοί που θα εμφανίζεται θα είναι έγκυροι.
*/
#include <stdio.h>
#include "genlib.h"
#include "simpio.h"
#include <math.h>

long encode(long arxikos_kod);
bool check(long telikos_kod);

int main(){
long telikos_kod,kodikos,ano_orio,j;
printf ("Lower limit :");
kodikos=GetLong();
printf("Upper limit :");
ano_orio=GetLong();
   telikos_kod=encode(j);
    if(check(telikos_kod)==TRUE){
        for(j=kodikos;j<=ano_orio;j++){
        printf("Code: %ld Encoding: %ld isValid:yes\n",j,encode(j));
    }
 }
return 0;}

long encode(long j){
 long digits,telikos_kod;
 digits=(98-(j*100)%97)%97;
 telikos_kod=j*100+digits;
 return telikos_kod;
}

bool check(long telikos_kod){
 long ypoloipo;
 ypoloipo=telikos_kod%97;
 if(ypoloipo==1){
    return TRUE;
 }else{
    return FALSE;
 }
}
